* Add full JavaDoc documentation to public API
* Add eager and lazy context methods (returns Iterable<ThreeTuple<Iterable<T>, T, Iterable<T>>>) (unwieldy)
* Add eager and lazy zip methods across 3 and 4 iterables (not sure about this)
* Add count methods
* Add cartesian product methods
* Add combination and permutation methods
* Add even, odd iterators over an underlying iterator (?) (not worth it)
* Add symmetric difference method to Multisets.
* Add union, intersection, difference and symmetric difference methods to Lists.
* Add concrete argument versions of all generic varargs functions
* Push all Eager methods into Lazy and rename Lazy to something more appropriate. The existing Eager methods are
  really just Collections methods
* Fix generics signatures (and potentially add tests) in Eager and Lazy
* Add Generator<T>, Yieldable<T>, GeneratorUtils, toGenerator on IteratorUtils and IterableUtils, toIterable and
  toIterator on GeneratorUtils
* Add whileTrue, untilTrue, doWhileTrue, doUntilTrue, ifTrue, unlessTrue with associated Condition and Block interfaces
* Add an Option<T> class
* Add an Either<S, T> class
* Rename *Tuple classes to Single, Pair, Triple, Quadruple, Quintuple, Sextuple, Septuple, Octuple, Nonuple
* Add interfaces for first, second, third etc.
* Add equivalentTo matcher and By.* equivalences
* Add Matcher versions of all methods taking Predicate arguments
* Add eventually matcher, resultOfPolling,  Sampler<T>, and CompletableSampler<T>
* Add SamplingIterator
* Add RepeatedlyIterator
* Consider Completable, Describable interfaces
* Add a validIterableContaining matcher and use it in all tests.
* Add a DirectoryIterator which iterates over File objects
* Split matchers out into their own project (?)
* Make Literals return immutable collections
* Add LambdaJ extension that allows LambdaJ style syntax when passing simple anonymous inner classes
* Add Enumerable.java extension that allows the use of lambdas and closures instead of passing anonymous inner classes
* Add collection wrappers extension such as FunctionalList, FunctionalSet that have methods on them that delegate
  to Iterables functions
  * e.g., list.reduce(Reducer<S, T> reduceFn); => reducedList

  Maybe
    Procedure/Block => execute
    Condition => evaluate

    Functor
    Procedure -> A functor with void return type
    Function -> A functor that returns an object of a specified type
    Predicate -> A functor that returns a boolean

    <NullaryX>
    <UnaryX>
    <BinaryX>
    <TernaryX>
    <QuaternaryX>
    <QuinaryX>
    <SenaryX>
    <SeptenaryX>
    <OctaryX>
    <NonaryX>

